

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>P3DFFT++ Tutorial &mdash; P3DFFT++ 3.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="P3DFFT++ C++ Reference" href="p3dfft++_c++_reference.html" />
    <link rel="prev" title="P3DFFT++ Documentation" href="p3dfft++_documentation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #db4c3f" >
          

          
            <a href="index.html" class="icon icon-home"> P3DFFT++
          

          
          </a>

          
            
            
              <div class="version">
                3.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="home.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="install_p3dfft.html">Install P3DFFT</a></li>
<li class="toctree-l1"><a class="reference internal" href="download_p3dfft.html">Download P3DFFT</a></li>
<li class="toctree-l1"><a class="reference internal" href="p3dfft_documentation.html">P3DFFT Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="install_p3dfft++.html">Install P3DFFT++</a></li>
<li class="toctree-l1"><a class="reference internal" href="download_p3dfft++.html">Download P3DFFT++</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="p3dfft++_documentation.html">P3DFFT++ Documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">P3DFFT++ Tutorial</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#general-considerations">General considerations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-types">Data types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-layout">Data layout</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#c">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fortran">Fortran</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#p3dfft-transforms">P3DFFT++ Transforms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#one-dimensional-1d-transforms">One-dimensional (1D) Transforms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">C</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">Fortran</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#three-dimensional-transforms">Three-dimensional Transforms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">Fortran</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="p3dfft++_c++_reference.html">P3DFFT++ C++ reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="p3dfft++_c_reference.html">P3DFFT++ C Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="p3dfft++_fortran_reference.html">P3DFFT++ Fortran Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="p3dfft++_c++_examples.html">P3DFFT++ C++ examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="p3dfft++_c_examples.html">P3DFFT++ C examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="p3dfft++_fortran_examples.html">P3DFFT++ Fortran examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contact.html">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="license_of_use.html">License of use</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">P3DFFT++</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="p3dfft++_documentation.html">P3DFFT++ Documentation</a> &raquo;</li>
        
      <li>P3DFFT++ Tutorial</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/p3dfft++_tutorial.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="p3dfft-tutorial">
<h1>P3DFFT++ Tutorial<a class="headerlink" href="#p3dfft-tutorial" title="Permalink to this headline">¶</a></h1>
<div class="section" id="general-considerations">
<h2>General considerations<a class="headerlink" href="#general-considerations" title="Permalink to this headline">¶</a></h2>
<p>P3DFFT++ is written in C++ and contains wrappers providing easy interfaces with C and Fortran.</p>
<p>For C++ users all P3DFFT++ objects are defined within the p3dfft namespace, in order to avoid confusion with user-defined objects. For example, to initialize P3DFFT++ it is necessary to call the function p3dfft::setup(), and to exit P3DFFT++ one should call p3dfft::cleanup() (alternatively, one can use namespace p3dfft and call setup() and cleanup()). From here on in this document we will omit the implicit p3dfft:: prefix from all C++ names.</p>
<p>In C and Fortran these functions become p3dfft_setup and p3dfft_cleanup.  While C++ users can directly access P3DFFT objects such as grid class, C and Fortran users will access these through handles provided by corresponding wrappers (see more details below).</p>
</div>
<div class="section" id="data-types">
<h2>Data types<a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h2>
<p>P3DFFT++ currently operates on four main data types:</p>
<ol class="arabic simple">
<li>float (single precision floating point)</li>
<li>double (double precision floating point)</li>
<li>mycomplex (single precision complex number) (equivalent to complex&lt;float&gt;)</li>
<li>complex_double (double precision complex number) (equivalent to complex&lt;double&gt;)</li>
</ol>
</div>
<div class="section" id="data-layout">
<h2>Data layout<a class="headerlink" href="#data-layout" title="Permalink to this headline">¶</a></h2>
<p>While P3DFFT had the assumption of predetermined 2D pencils in X and in Z dimensions as the primary data storage, P3DFFT++ relaxes this assumption to include more general formats, such as arbitrary shape and memory order 2D pencils as well as 3D blocks. Below is the technical description of how to specify the data layout formats.</p>
<p>A basic P3DFFT++ descriptor is the &quot;grid&quot; construct. It defines all necessary information about decomposition of a grid among parallel tasks/processors. In C++ it is defined as a class, while in C and in Fortran it is defined through handles to a C++ object through inter-language wrappers. Below is the technical description of the definition for each language.</p>
<div class="section" id="c">
<h3>C++<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h3>
<p>The following is the main constructor call for the <em>grid</em> class:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span><span class="p">(</span><span class="kt">int</span> <span class="n">gdims</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="kt">int</span> <span class="n">dim_conj_sym</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pgrid</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="kt">int</span> <span class="n">proc_order</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="kt">int</span> <span class="n">mem_order</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">MPI_Comm</span> <span class="n">mpicomm</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Arguments</em>:</p>
<table border="1" class="colwidths-auto docutils">
<tbody valign="top">
<tr class="row-odd"><td><em>gdims</em></td>
<td>The three global dimensions of the grid to be decomposed. Here the Fortran-inspired convention is followed: the first of the three numbers specifies the dimension with the fastest changing index, i.e. the first logical dimension (X).</td>
</tr>
<tr class="row-even"><td><em>dim_conj_sym</em></td>
<td>The dimension of conjugate symmetry where we store N/2+1 of the data after Real-to-complex transform due to conjugate symmety;(-1 for none)</td>
</tr>
<tr class="row-odd"><td><em>pgrid</em></td>
<td>The processor grid to be used in decomposition. For example, a 2D pencil with the first dimension local (X-pencil) would be described as having pgrid={1,P1,P2}, where P1 and P2 are the dimensions of 2D decomposition such that P1 x P2 = P, the total number of tasks. Of course a 2D grid could be defined as a Y-pencil (pgrid={P1,1,P2}) or a Z pencil (P1,P2,1). 1D decomposition (slabs) would be defined as (1,1,P), or (1,P,1) or (P,1,1), depending on the orientation of the slabs. 3D decomposition is also possible where each of the three values of pgrid is greater than 1.</td>
</tr>
<tr class="row-even"><td><em>proc_order</em></td>
<td>The ordering of the processor grid dimensions with respect to the default layout of MPI tasks. For example, the simplest ordering where proc_order={0,1,2} and pgrid={1,P1,P2} corresponds to a grid with the second dimension decomposed among P1 MPI tasks adjacent to each other in the default MPI topology, such as tasks on the same node and/or neighboring nodes on the network, while the third dimension would be decomposed among P2 tasks on non-neighboring nodes (with stride equal to P1). On the other hand, proc_order={0,2,1} with the same pgrid would correspond to P2 tasks splitting the third dimension of the grid being adjacent in the MPI/network neighborhood, while the second dimension would be split over P1 tasks distant in the topology with stride equal to P2.</td>
</tr>
<tr class="row-odd"><td><em>mem_order</em></td>
<td>The relative ordering of the three dimensions in memory within the local portion of the grid. Here C-style indexing is used (indices start with 0). The simplest ordering {0,1,2} corresponds to the first logical dimension being stored with the fastest changing index (memory stride=1), followed by the second (stride=L0) and the third dimension (stride=L0*L1), where Li is the size of local grid in i's dimension for a given MPI task. This corresponds to a C array A[L2][L1][L0]. As another example, ordering {2,0,1} means that the second dimension (L1) is stored with the fastest-changing index (memory stride=1), the third dimension dimension (L2) with the medium stride =L1, and the first dimension is stored with the slowest index, stride=L1*L2. This would correspond to a C array A[L0][L2][L1].</td>
</tr>
<tr class="row-even"><td><em>mpicomm</em></td>
<td>The initial communicator for all subsequent library operations. It is recommended that the users define or duplicate a communicator for P3DFFT++ to be different from the one(s) used in their code, in order to avoid interference.</td>
</tr>
</tbody>
</table>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">main</span><span class="p">()</span> <span class="p">{</span>

<span class="p">...</span>

<span class="kt">int</span> <span class="n">gdims</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">pgrid</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">proc_order</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">mem_order</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="n">MPI_Comm</span> <span class="n">mpicomm</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">gdims</span><span class="o">=</span> <span class="p">{</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">};</span>

<span class="n">pgrid</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span> <span class="c1">//X-pencil</span>

<span class="n">proc_order</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>

<span class="n">mem_order</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>

<span class="n">MPI_Comm_dup</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mpicomm</span><span class="p">);</span>

<span class="n">grid</span> <span class="nf">mygrid</span><span class="p">(</span><span class="n">gdims</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">pgrid</span><span class="p">,</span> <span class="n">proc_order</span><span class="p">,</span> <span class="n">mem_order</span><span class="p">,</span> <span class="n">mpicomm</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
<p>Upon construction the <em>grid</em> object defines several useful parameters, available by accessing the following public class members of <em>grid</em>:</p>
<table border="1" class="colwidths-auto docutils">
<tbody valign="top">
<tr class="row-odd"><td><em>int ldims[3]</em></td>
<td>Dimensions of the local portion of the grid (ldims[0]=gdims[0]/pgrid[0] etc). Note: these dimensions are specified in the order of logical grid dimensions and may differ from memory storage order, which is defined by <em>mem_order</em>.</td>
</tr>
<tr class="row-even"><td><em>int nd</em></td>
<td>Number of dimensions of the processor grid (1, 2 or 3).</td>
</tr>
<tr class="row-odd"><td><em>int L[3]</em></td>
<td>0 to 3 local dimensions (i.e. not split).</td>
</tr>
<tr class="row-even"><td><em>int D[3]</em></td>
<td>0 to 3 split dimensions.</td>
</tr>
<tr class="row-odd"><td><em>int glob_start[3]</em></td>
<td>Coordinates of the lowest element of the local grid within the global array. This is useful for reconstructing the global grid from grid pieces for each MPI task.</td>
</tr>
</tbody>
</table>
<p>and other useful information.  The grid class also provides a copy constructor.</p>
<p>To release a grid object, simply delete it.</p>
<div class="section" id="id1">
<h4>C<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>For C users grid initialization is accomplished by a call to p3dfft_init_grid, returning a pointer to an object of type <em>Grid</em>. This type is a C structure containing a large part of the C++ class <em>grid</em>. Calling p3dfft_init_grid initializes the C++ <em>grid</em> object and also copies the information into a <em>Grid</em> object accessible from C, returning its pointer. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">xdim</span><span class="p">;</span>

<span class="n">Grid</span> <span class="o">*</span><span class="n">grid1</span><span class="p">;</span>

<span class="n">grid1</span> <span class="o">=</span> <span class="n">p3dfft_init_grid</span><span class="p">(</span><span class="n">gdims</span><span class="p">,</span> <span class="n">dim_conj_sym</span><span class="p">,</span> <span class="n">pgrid</span><span class="p">,</span> <span class="n">proc_order</span><span class="p">,</span> <span class="n">mem_order</span><span class="p">,</span> <span class="n">mpicomm</span><span class="p">);</span>

<span class="n">xdim</span> <span class="o">=</span> <span class="n">grid1</span><span class="o">-&gt;</span><span class="n">ldims</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* Size of zero logical dimension of the local portion of the grid for a given processor */</span>

<span class="n">To</span> <span class="n">release</span> <span class="n">a</span> <span class="n">grid</span> <span class="n">object</span> <span class="n">simply</span> <span class="n">execute</span>

<span class="nf">p3dfft_free_grid</span><span class="p">(</span><span class="n">Grid</span> <span class="o">*</span><span class="n">gr</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fortran">
<h3>Fortran<a class="headerlink" href="#fortran" title="Permalink to this headline">¶</a></h3>
<p>For Fortran users the grid object is represented as a handle of type <em>integer(C_INT)</em>. For example:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">integer</span><span class="p">(</span><span class="kt">C_INT</span><span class="p">)</span> <span class="n">grid1</span>

<span class="kt">integer </span><span class="n">ldims</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">glob_start</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">gdims</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">dim_conj_sym</span><span class="p">,</span><span class="n">pgrid</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">proc_order</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">mem_order</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="n">mpicomm</span>

<span class="n">grid1</span> <span class="o">=</span> <span class="n">p3dfft_init_grid</span><span class="p">(</span><span class="n">ldims</span><span class="p">,</span> <span class="n">glob_start</span><span class="p">,</span> <span class="n">gdims</span><span class="p">,</span> <span class="n">dim_conj_sym</span><span class="p">,</span> <span class="n">pgrid</span><span class="p">,</span> <span class="n">proc_order</span><span class="p">,</span> <span class="n">mem_order</span><span class="p">,</span> <span class="n">mpicomm</span><span class="p">)</span>
</pre></div>
</div>
<p>This call initializes a C++ grid object as a global variable and assigns an integer ID, returned in this example as <em>grid1</em>. In addition this call also returns the dimensions of the local portion of the grid (<em>ldims</em>) and the position of this portion within the global array (<em>glob_start</em>).</p>
<p>Other elements of the C++ grid object can be accessed through respective functions, such as p3dfft_grid_get_...</p>
<p>To release a grid object, simply call:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="o">*</span><span class="n">p3dfft_free_grid_f</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span><span class="o">*</span>
</pre></div>
</div>
<p>where <em>gr</em> is the grid handle.</p>
</div>
</div>
<div class="section" id="p3dfft-transforms">
<h2>P3DFFT++ Transforms<a class="headerlink" href="#p3dfft-transforms" title="Permalink to this headline">¶</a></h2>
<p>P3DFFT++ aims to provide a versatile toolkit of algorithms/transforms in frequent use for solving multiscale problems. To give the user maximum flexibility there is a range of algorithms from top-level algorithms operating on the entire 3D array, to 1D algorithms which can function as building blocks the user can arrange to suit his/her needs. In addition, inter-processor exchanges/transposes are provided, so as to enable the user to rearrange the data from one orientation of  pencils to another, as well as other types of exchanges. In P3DFFT++ the one-dimensional transforms are assumed to be expensive in terms of memory bandwidth, and therefore such transforms are performed on local data (i.e. in the dimension that is not distributed across processor grid). Transforms in three dimensions consist of three transforms in one dimension, interspersed by inter-processor interchange as needed to rearrange the data.  The 3D transforms are  high-level functions saving the user work in arranging the 1D transforms and transposes, as well as often providing superior performance. <strong>We recommend to use 3D transforms whenever they fit the user's algorithm.</strong></p>
<p>Although syntax for C++, C and Fortran is different, using P3DFFT++ follows the same logic. P3DFFT++ functions in a way similar to FFTW: first the user needs to plan a transform, using a planner function once per each transform type. The planner function initializes the transform, creates a plan and stores all information relevant to this transform inside P3DFFT++. The users gets a handle referring to this plan (the handle is a class in C++, and an integer variable in C or Fortran) that can be later used to execute this transform, which can be applied multiple times. The handles can be released after use.</p>
<p>In order to define and plan a transform (whether 1D or 3D, in C++, C or Fortran) one needs to first define initial and final grid objects. They contain all the necessary grid decomposition parameters. P3DFFT++ figures out the optimal way to transpose the data between these two grid configurations, assuming they are consistent (i.e. same grid size, number of tasks etc).</p>
</div>
<div class="section" id="one-dimensional-1d-transforms">
<h2>One-dimensional (1D) Transforms<a class="headerlink" href="#one-dimensional-1d-transforms" title="Permalink to this headline">¶</a></h2>
<p>1D transforms is the smaller building block for higher dimensional transforms in P3DFFT++. They include different flavors of Fast Fourier Transforms (FFTs), empty transform (provided for convenience, as in the case where a user might want to implement their own 1D transform, but is interested in memory reordering to arrange the transform dimension for stride-1 data access), and (in the future) other transforms that share the following property: they are memory bandwidth and latency intensive,  and are optimally done when the dimension the transform operates on is entirely within one MPI task's domain.</p>
<p>1D transforms can be done with or without data exchange and/or memory reordering. In general, combining a transform with an exchange/reordering can be beneficial for performance due to cache reuse, compared to two separate calls to a transform and an exchange.</p>
<p>The following predefined 1D transforms are available (in C++ the P3DFFT_ prefix can be omitted if used within P3DFFT namespace).</p>
<table border="1" class="colwidths-auto docutils">
<tbody valign="top">
<tr class="row-odd"><td>P3DFFT_EMPTY_TYPE</td>
<td>Empty transform</td>
</tr>
<tr class="row-even"><td>P3DFFT_R2CFFT_S, P3DFFT_R2CFFT_D</td>
<td>Real-to-complex forward FFT (as defined in FFTW manual), in single and double precision respectively</td>
</tr>
<tr class="row-odd"><td>P3DFFT_C2RFFT_S, P3DFFT_C2RFFT_D</td>
<td>Complex-to-real backward FFT (as defined in FFTW manual), in single and double precision respectively</td>
</tr>
<tr class="row-even"><td>P3DFFT_CFFT_FORWARD_S, P3DFFT_CFFT_FORWARD_D</td>
<td>Complex forward FFT (as defined in FFTW manual), in single and double precision respectively</td>
</tr>
<tr class="row-odd"><td>P3DFFT_CFFT_BACKWARD_S, P3DFFT_CFFT_BACKWARD_D</td>
<td>Complex backward FFT (as defined in FFTW manual), in single and double precision respectively</td>
</tr>
<tr class="row-even"><td>P3DFFT_DCT&lt;x&gt;_REAL_S, P3DFFT_DCT1_REAL_D</td>
<td>Cosine transform for real-numbered data, in single and double precision, where &lt;x&gt; stands for the variant of the cosine transform, such as DCT1, DCT2, DCT3 or DCT4</td>
</tr>
<tr class="row-odd"><td>P3DFFT_DST&lt;x&gt;_REAL_S, P3DFFT_DST1_REAL_D</td>
<td>Sine transform for real-numbered data, in single and double precision, where &lt;x&gt; stands for the variant of the cosine transform, such as DST1, DST2, DST3 or DST4</td>
</tr>
<tr class="row-even"><td>P3DFFT_DCT&lt;x&gt;_COMPLEX_S, P3DFFT_DCT1_COMPLEX_D</td>
<td>Cosine transform for complex-numbered data, in single and double precision, where &lt;x&gt; stands for the variant of the cosine transform, such as DCT1, DCT2, DCT3 or DCT4</td>
</tr>
<tr class="row-odd"><td>P3DFFT_DST&lt;x&gt;_COMPLEX_S, P3DFFT_DST1_COMPLEX_D</td>
<td>Sine transform for complex-numbered data, in single and double precision, where &lt;x&gt; stands for the variant of the cosine transform, such as DST1, DST2, DST3 or DST4</td>
</tr>
</tbody>
</table>
<div class="section" id="id2">
<h3>C++<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Below is an example of how a 1D transform can be called from C++. In this example, real-to-complex transform in double precision is planned and then performed. First a constructor for class transplan is called:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">transplan</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="n">complex_double</span><span class="o">&gt;</span> <span class="n">trans_f</span><span class="p">(</span><span class="n">gridIn</span><span class="p">,</span> <span class="n">gridOut</span><span class="p">,</span> <span class="n">R2C_FFT_D</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <em>gridIn</em> and <em>gridOut</em> are initial and final <em>grid</em> objects, describing, among other things, initial and final memory ordering of the grid storage array (ordering can be the same or different for input and output). <em>dim</em> is the dimension/rank to be transformed. Note that this is the logical dimension rank (0 for X, 1 for Y, 2 for Z), and may not be the same as the storage dimension, which depends on <em>mem_order</em> member of <em>gridIn</em> and <em>gridOut</em>. The transform dimension of the grid is assumed to be MPI task-local. The second last parameter is a bool variable telling P3DFFT++ whether this is an in-place or out-of-place transform. Note that in C++ the P3DFFT_ prefix for transform types is optional.</p>
<p>When a <em>transplan</em> constructor is called as above, P3DFFT++ stores the parameters of the 1D transform and if needed, plans its execution (i.e. as in FFTW planning) and stores the plan handle. This needs to be done once per transform type. In order to execute the transform, simply call exec member of the class, e.g.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">trans_f</span><span class="p">.</span><span class="n">exec</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">In</span><span class="p">,(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">Out</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <em>In</em> and <em>Out</em> are pointers to input and output arrays. In this case they are of type <em>double</em> and <em>complex_double</em>, however in this call they are cast as <em>char*</em>, as required by P3DFFT++. They contain the local portion of the 3D input and output arrays, arranged as a contiguous sequence of numbers according to local grid dimensions and the memory order of <em>gridIn</em> and <em>gridOut</em> classes, respectively. If the transform is out-of-place, then these arrays must be non-overlapping. The execution can be performed many times with the same handle and same or different input and output arrays.This call will perform the 1D transform specified when the <em>transplan</em> object was constructed, along the dimension <em>dim</em>. Again, the logical dimension specified as <em>dim</em> in the planning stage must be MPI-local for both input and output arrays. Other utilities allow the user to transpose the grid arrays in MPI/processor space (<em>see MPIplan and transMPIplan</em>).</p>
<p>To release the transform handle simply delete the transplan class object.</p>
</div>
<div class="section" id="id3">
<h3>C<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Here is an example of initializing and executing a 1D transform (again, a real-to-complex double precision FFT) in a C program.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Grid</span> <span class="o">*</span><span class="n">gridIn</span><span class="p">,</span> <span class="o">*</span><span class="n">gridOut</span><span class="p">;</span>

<span class="n">Plan3D</span> <span class="n">trans_f</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">gridIn</span> <span class="o">=</span> <span class="n">p3dfft_init_grid</span><span class="p">(</span><span class="n">gdimsIn</span><span class="p">,</span> <span class="n">pgridIn</span><span class="p">,</span> <span class="n">proc_order</span><span class="p">,</span> <span class="n">mem_orderIn</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
<span class="n">gridOut</span> <span class="o">=</span> <span class="n">p3dfft_init_grid</span><span class="p">(</span><span class="n">gdimsOut</span><span class="p">,</span> <span class="n">pgridOut</span><span class="p">,</span> <span class="n">proc_order</span><span class="p">,</span> <span class="n">mem_orderOut</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">);</span>

<span class="n">trans_f</span> <span class="o">=</span> <span class="n">p3dfft_plan_1Dtrans</span><span class="p">(</span><span class="n">gridIn</span><span class="p">,</span> <span class="n">gridOut</span><span class="p">,</span> <span class="n">P3DFFT_R2CFFT_D</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <em>gridIn</em> and <em>gridOut</em> are pointers to the C equivalent of P3DFFT++ <em>grid</em> object (initial and final), <em>trans_f</em> is the handle for the 1D transform after it has been initialized and planned, <em>dim</em> is the logical dimension of the transform (0, 1 or 2), and the last argument indicates that this is not an in-place transform (a non-zero argument would indicate in-place). This initialization/planning needs to be done once per transform type.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">p3dfft_exec_1Dtrans_double</span><span class="p">(</span><span class="n">trans_f</span><span class="p">,</span><span class="n">IN</span><span class="p">,</span><span class="n">OUT</span><span class="p">);</span>
</pre></div>
</div>
<p>This statement executes the 1D transformed planned and handled by <em>trans_f</em>. <em>IN</em> and <em>OUT</em> are pointers to one-dimensional input and output arrays containing the 3D grid stored contiguously in memory based on the local grid dimensions and storage order of <em>gridIn</em> and <em>gridOut</em>. The execution can be performed many times with the same handle and same or different input and output arrays. In case of out-of-place transform the input and output arrays must be non-overlapping.</p>
</div>
<div class="section" id="id4">
<h3>Fortran<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Here is an example of initializing and executing a 1D transform (again, a real-to-complex double precision FFT) in a Fortran program:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">integer</span><span class="p">(</span><span class="kt">C_INT</span><span class="p">)</span> <span class="n">gridIn</span><span class="p">,</span><span class="n">gridOut</span>
<span class="kt">integer </span><span class="n">trans_f</span>

<span class="n">gridIn</span> <span class="o">=</span> <span class="n">p3dfft_init_grid</span><span class="p">(</span><span class="n">ldimsIn</span><span class="p">,</span> <span class="n">glob_startIn</span><span class="p">,</span> <span class="n">gdimsIn</span><span class="p">,</span> <span class="n">pgridIn</span><span class="p">,</span> <span class="n">proc_order</span><span class="p">,</span> <span class="n">mem_orderIn</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">)</span>
<span class="n">gridOut</span> <span class="o">=</span> <span class="n">p3dfft_init_grid</span><span class="p">(</span><span class="n">ldimsOut</span><span class="p">,</span> <span class="n">glob_startOut</span><span class="p">,</span> <span class="n">gdimsOut</span><span class="p">,</span> <span class="n">pgridOut</span><span class="p">,</span> <span class="n">proc_order</span><span class="p">,</span> <span class="n">mem_orderOut</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">)</span>
<span class="n">trans_f</span> <span class="o">=</span> <span class="n">p3dfft_plan_1Dtrans_f</span><span class="p">(</span><span class="n">gridIn</span><span class="p">,</span> <span class="n">gridOut</span><span class="p">,</span> <span class="n">P3DFFT_R2CFFT_D</span><span class="p">,</span> <span class="nb">dim</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>These statement set up initial and final grids (gridIn and gridOut), initialize and plan the 1D real-to-complex double FFT and use trans_f as its handle. This needs to be done once per transform type. Note that we need to translate the transform dimension dim into C convention (so that X corresponds to 0, Y to 1 and Z to 2). The last argument is 0 for out-of-place and non-zero for in-place transform.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">p3dfft_1Dtrans_double</span><span class="p">(</span><span class="n">trans_f</span><span class="p">,</span><span class="n">Gin</span><span class="p">,</span><span class="n">Gout</span><span class="p">)</span>
</pre></div>
</div>
<p>This statement executes the 1D transform planned before and handled by trans_f. Gin and Gout are 1D contiguous arrays of values (double precision and double complex) of the 3D grid array, according to the local grid dimensions and memory storage order of gridIn and gridOut, respectively. After the previous planning step is complete, the execution can be called many times with the same handle and same or different input and output arrays. If the transform was declared as out-of-place then Gin and Gout must be non-overlapping.</p>
</div>
</div>
<div class="section" id="three-dimensional-transforms">
<h2>Three-dimensional Transforms<a class="headerlink" href="#three-dimensional-transforms" title="Permalink to this headline">¶</a></h2>
<p>As mentioned above, three-dimensional (3D) transforms consist of three one-dimensional transforms in sequence (one for each dimension), interspersed by inter-processor transposes. In order to specify a 3D transform, five main things are needed:</p>
<ol class="arabic simple">
<li>Initial <em>grid</em> (as described above, <em>grid</em> object defines all of the specifics of grid dimensions, memory ordering and distribution among processors).</li>
<li>Final <em>grid</em>.</li>
<li>The type of 3D transform.</li>
<li>Whether this is in-place transform</li>
<li>Whether this transform can overwrite input</li>
</ol>
<p>The final grid may or may not be the same as the initial grid. First, in real-to-complex and complex-to-real transforms the global grid dimensions change for example from (n0,n1,n2) to (n0/2+1,n1,n2), since most applications attempt to save memory by using the conjugate symmetry of the Fourier transform of real data. Secondly, the final grid may have different processor distribution and memory ordering, since for example many applications with convolution and those solving partial differential equations do not need the initial grid configuration in Fourier space. The flow of these applications is typically 1) transform from physical to Fourier space, 2) apply convolution or derivative calculation in Fourier space, and 3) inverse FFT to physical space. Since forward FFT's last step is 1D FFT in the third dimension, it is more efficient to leave this dimension local and stride-1, and since the first step of the inverse FFT is to start with the third dimension 1D FFT, this format  naturally fits the algorithm and results in big savings of time due to elimination of several extra transposes.</p>
<p>In order to define the 3D transform type one needs to know three 1D transform types comprising the 3D transform. Usage of 3D transforms is different depending on the language used and is described below.</p>
<div class="section" id="id5">
<h3>C++<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>In C++ 3D transform type is interfaced through a class trans_type3D, which is constructed as in the following example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">trans_type3D</span> <span class="nf">name_type3D</span><span class="p">(</span><span class="kt">int</span> <span class="n">types1D</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</pre></div>
</div>
<p>Here <em>types1D</em> is the array of three 1D transform types which define the 3D transform (empty transforms are permitted). Copy constructor is also provided for this class.</p>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">type_rcc</span><span class="p">,</span> <span class="n">type_ids</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="n">type_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">P3DFFT_R2CFFT_D</span><span class="p">;</span>
<span class="n">type_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">P3DFFT_CFFT_FORWARD_D</span><span class="p">;</span>
<span class="n">type_ids</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">P3DFFT_CFFT_FORWARD_D</span><span class="p">;</span>

<span class="n">trans_type3D</span> <span class="nf">mytype3D</span><span class="p">(</span><span class="n">type_ids</span><span class="p">);</span>
</pre></div>
</div>
<p>3D transforms are provided as the class template:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">TypeIn</span><span class="p">,</span><span class="k">class</span> <span class="nc">TypeOut</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">transform3D</span><span class="p">;</span>
</pre></div>
</div>
<p>Here <em>TypeIn</em> and <em>TypeOut</em> are initial and final data types. Most of the times these will be the same, however some transforms have different types on input and output, for example real-to-complex FFT. In all cases the floating point precision (single/double) of the initial and final types should match.</p>
<p>The constructor of transform3D takes the following arguments:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">transform3D</span><span class="o">&lt;</span><span class="n">TypeIn</span><span class="p">,</span><span class="n">TypeOut</span><span class="o">&gt;</span>  <span class="n">my_transform_name</span><span class="p">(</span><span class="n">gridIn</span><span class="p">,</span><span class="n">gridOut</span><span class="p">,</span><span class="n">type</span><span class="p">,</span><span class="n">inplace</span><span class="p">,</span><span class="n">overwrite</span><span class="p">);</span>
</pre></div>
</div>
<p>Here type is a 3D transform type (constructed as shown above), inplace is a bool variable indicating whether this is an in-place transform, and overwrites (also boolean) defines if the input can be rewritten (default is false). <em>gridIn</em> and <em>gridOut</em> are initial and final grid objects. Calling a <em>transform3D</em> constructor creates a detailed step-by-step plan for execution of the 3D transform and stores it in the <em>my_transform_name</em> object.</p>
<p>Once a 3D transform has been defined and planned, execution of a 3D transform can be done by calling:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">my_transform_name</span><span class="p">.</span><span class="n">exec</span><span class="p">(</span><span class="n">TypeIn</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span><span class="n">TypeOut</span> <span class="o">*</span><span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <em>in</em> and <em>out</em> are initial and final data arrays of appropriate types. These are assumed to be one-dimensional contiguous arrays containing the three-dimensional grid for input and output, local to the memory of the given MPI task, and stored according to the dimensions and memory ordering specified in the <em>gridIn</em> and <em>gridOut</em> objects, respectively.  For example, if grid1.ldims={2,2,4} and grid1.mem_order={2,1,0}, then the in array will contain the following sequence: G000, G001, G002, G003, G010, G011, G012, G013, G100, G101, G102, G103, G110, G111, G112, G113. Again, we follow the Fortran convention that the fastest running index is the first, (i.e. G012 means the grid element at X=0, Y=1, Z=2).</p>
<div class="section" id="id6">
<h4>C<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>In C a unique datatype Type3D is used to define the 3D transform needed. <em>p3dfft_init_3Dtype</em> function is used to initialize a new 3D transform type, based on the three 1D transform types, as in the following example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">type_rcc</span><span class="p">,</span>  <span class="n">type_ids</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="n">type_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">P3DFFT_R2CFFT_D</span><span class="p">;</span>
<span class="n">type_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">P3DFFT_CFFT_FORWARD_D</span><span class="p">;</span>
<span class="n">type_ids</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">P3DFFT_CFFT_FORWARD_D</span><span class="p">;</span>

<span class="n">type_rcc</span> <span class="o">=</span> <span class="n">p3dfft_init_3Dtype</span><span class="p">(</span><span class="n">type_ids</span><span class="p">);</span>
</pre></div>
</div>
<p>In this example type_rcc will describe the real-to-complex (R2C) 3D transform (R2C in 1D followed by two complex 1D transforms).</p>
<p>To define and plan the 3D transform, use p3dfft_plan_3Dtrans function as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">mytrans</span><span class="p">;</span>

<span class="n">mytrans</span> <span class="o">=</span> <span class="n">p3dfft_plan_3Dtrans</span><span class="p">(</span><span class="n">gridIn</span><span class="p">,</span><span class="n">gridOut</span><span class="p">,</span><span class="n">type</span><span class="p">,</span><span class="n">inplace</span><span class="p">,</span><span class="n">overwrite</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <em>gridIn</em> and <em>gridOut</em> are pointers to initial and final grid objects (of type <em>Grid</em>); <em>type</em> is the 3D transform type defined as above; <em>inplace</em> is an integer indicating an in-place transform if it's non-zero, out-of-place otherwise. Overwrite is an integer defining if the input can be overwritten (non-zero; default is zero). In this example <em>mytrans</em> contains the handle to the 3D transform that can be executed (many times) as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">p3dfft_exec_3Dtrans_double</span><span class="p">(</span><span class="n">mytrans</span><span class="p">,</span><span class="n">in</span><span class="p">,</span><span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <em>in</em> and <em>out</em> are pointers to input and output arrays, as before, assumed to be the local portion of the 3D grid array stored according to <em>gridIn</em> and <em>gridOut</em> descriptors. For single precision use <em>p3dfft_exec_3Dtrans_single</em>.</p>
</div>
</div>
<div class="section" id="id7">
<h3>Fortran<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>In Fortran, similar to C, to define a 3D transform the following routine is used:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">mytrans</span> <span class="o">=</span> <span class="n">p3dfft_plan_3Dtrans_f</span><span class="p">(</span><span class="n">gridIn</span><span class="p">,</span><span class="n">gridOut</span><span class="p">,</span><span class="k">type</span><span class="p">,</span><span class="n">inplace</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <em>gridIn</em> and <em>gridOut</em> are handles defining the initial and final grid configurations; <em>type</em> is the 3D transform type, defined as above; and <em>inplace</em> is the integer whose non-zero value indicates this is an in-place transform (or 0 for out-of-place). Non-zero overwrite indicates it is OK to overwrite input (default is no). Again, this planner routine is called once per transform. Execution can be called multiple times as follows:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">call </span><span class="n">p3dfft_3Dtrans_double</span><span class="p">(</span><span class="n">mytrans</span><span class="p">,</span><span class="n">IN</span><span class="p">,</span><span class="n">OUT</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <em>IN</em> and <em>OUT</em> are the input and output arrays. For single precision use <em>p3dfft_3Dtrans_single_f</em>.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="p3dfft++_c++_reference.html" class="btn btn-neutral float-right" title="P3DFFT++ C++ Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="p3dfft++_documentation.html" class="btn btn-neutral float-left" title="P3DFFT++ Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Dmitry Pekurovsky

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>