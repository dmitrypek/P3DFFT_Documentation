

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>P3DFFT++ C++ Reference &mdash; P3DFFT++ 3.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="P3DFFT++ C Reference" href="p3dfft++_c_reference.html" />
    <link rel="prev" title="P3DFFT++ Tutorial" href="p3dfft++_tutorial.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #db4c3f" >
          

          
            <a href="index.html" class="icon icon-home"> P3DFFT++
          

          
          </a>

          
            
            
              <div class="version">
                3.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="home.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="install_p3dfft.html">Install P3DFFT</a></li>
<li class="toctree-l1"><a class="reference internal" href="download_p3dfft.html">Download P3DFFT</a></li>
<li class="toctree-l1"><a class="reference internal" href="p3dfft_documentation.html">P3DFFT Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="install_p3dfft++.html">Install P3DFFT++</a></li>
<li class="toctree-l1"><a class="reference internal" href="download_p3dfft++.html">Download P3DFFT++</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="p3dfft++_documentation.html">P3DFFT++ Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="p3dfft++_tutorial.html">P3DFFT++ Tutorial</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">P3DFFT++ C++ reference</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setup-and-grid-layout">Setup and Grid layout</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#grid-constructor"><em>grid</em> constructor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#p3dfft-transforms">P3DFFT++ Transforms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#one-dimensional-1d-transforms">One-Dimensional (1D) Transforms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#three-dimensional-transforms">Three-dimensional Transforms</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="p3dfft++_c_reference.html">P3DFFT++ C Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="p3dfft++_fortran_reference.html">P3DFFT++ Fortran Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="p3dfft++_c++_examples.html">P3DFFT++ C++ examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="p3dfft++_c_examples.html">P3DFFT++ C examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="p3dfft++_fortran_examples.html">P3DFFT++ Fortran examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contact.html">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="license_of_use.html">License of use</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">P3DFFT++</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="p3dfft++_documentation.html">P3DFFT++ Documentation</a> &raquo;</li>
        
      <li>P3DFFT++ C++ Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/p3dfft++_c++_reference.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="p3dfft-c-reference">
<h1><a class="toc-backref" href="#id1">P3DFFT++ C++ Reference</a><a class="headerlink" href="#p3dfft-c-reference" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#p3dfft-c-reference" id="id1">P3DFFT++ C++ Reference</a><ul>
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a></li>
<li><a class="reference internal" href="#setup-and-grid-layout" id="id3">Setup and Grid layout</a><ul>
<li><a class="reference internal" href="#grid-constructor" id="id4"><em>grid</em> constructor</a></li>
</ul>
</li>
<li><a class="reference internal" href="#p3dfft-transforms" id="id5">P3DFFT++ Transforms</a><ul>
<li><a class="reference internal" href="#one-dimensional-1d-transforms" id="id6">One-Dimensional (1D) Transforms</a><ul>
<li><a class="reference internal" href="#custom-transform-types" id="id7">Custom transform types</a></li>
<li><a class="reference internal" href="#planning-1d-transform" id="id8">Planning 1D transform</a></li>
<li><a class="reference internal" href="#releasing-1d-transform-handle" id="id9">Releasing 1D transform handle</a></li>
<li><a class="reference internal" href="#executing-1d-transform" id="id10">Executing 1D transform</a></li>
</ul>
</li>
<li><a class="reference internal" href="#three-dimensional-transforms" id="id11">Three-dimensional Transforms</a><ul>
<li><a class="reference internal" href="#trans-type3d-constructor" id="id12">trans_type3D constructor</a></li>
<li><a class="reference internal" href="#transform3d-constructor" id="id13">Transform3D constructor</a></li>
<li><a class="reference internal" href="#transform3d-execution" id="id14">Transform3D Execution</a></li>
<li><a class="reference internal" href="#spectral-derivative-for-3d-array" id="id15">Spectral Derivative for 3D array</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id2">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>For C++ users all P3DFFT++ objects are defined within the p3dfft namespace, in order to avoid confusion with user-defined objects. For example, to initialize P3DFFT++ it is necessary to call the function p3dfft::setup(), and to exit P3DFFT++ one should call p3dfft::cleanup() (alternatively, one can use namespace p3dfft and call setup() and cleanup()). From here on in this document we will omit the implicit p3dfft:: prefix from all C++ names.</p>
</div>
<div class="section" id="setup-and-grid-layout">
<h2><a class="toc-backref" href="#id3">Setup and Grid layout</a><a class="headerlink" href="#setup-and-grid-layout" title="Permalink to this headline">¶</a></h2>
<p>The public portion of the grid class is below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">grid</span> <span class="p">{</span>

<span class="p">...</span>

<span class="k">public</span> <span class="o">:</span>

<span class="kt">int</span> <span class="n">taskid</span><span class="p">,</span><span class="n">numtasks</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">nd</span><span class="p">;</span> <span class="c1">//number of dimensions the volume is split over</span>

<span class="kt">int</span> <span class="n">gdims</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">//Global dimensions</span>

<span class="n">dim_conj_sym</span><span class="p">;</span> <span class="c1">// dimension of the array in which a little less than half of the elements are omitted due to conjugate symmetry. This argument should be non-negative only for complex-valued arrays resulting from real-to-complex FFT in the given dimension.</span>

<span class="kt">int</span> <span class="n">mem_order</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">//Memory ordering inside the data volume</span>
<span class="kt">int</span> <span class="n">ldims</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">//Local dimensions on THIS processor</span>
<span class="kt">int</span> <span class="n">pgrid</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">//Processor grid</span>
<span class="kt">int</span> <span class="n">proc_order</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">//Ordering of tasks in processor grid, e.g. (1,2,3) : first dimension - adjacent tasks,then second, then third dimension</span>
<span class="kt">int</span> <span class="n">P</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">//Processor grid size (in inverse order of split dimensions, i.e. rows first, then columns etc</span>
<span class="kt">int</span> <span class="n">D</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">//Ranks of Dimensions of physical grid split over rows and columns correspondingly</span>
<span class="kt">int</span> <span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">//Rank of Local dimension (p=1)</span>
<span class="kt">int</span> <span class="n">grid_id</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">//Position of this pencil/cube in the processor grid</span>
<span class="kt">int</span> <span class="n">grid_id_cart</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">glob_start</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// Starting coords of this cube in the global grid</span>
<span class="n">MPI_Comm</span> <span class="n">mpi_comm_glob</span><span class="p">;</span> <span class="c1">// Global MPi communicator we are starting from</span>
<span class="n">MPI_Comm</span> <span class="n">mpi_comm_cart</span><span class="p">;</span>
<span class="n">MPI_Comm</span> <span class="n">mpicomm</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">//MPI communicators for each dimension</span>
<span class="c1">// int (*st)[3],(*sz)[3],(*en)[3]; // Lowest, size and uppermost location in 3D, for each processor in subcommunicator</span>
<span class="kt">int</span> <span class="o">**</span><span class="n">st</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="o">**</span><span class="n">sz</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="o">**</span><span class="n">en</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// Lowest, size and uppermost location in 3D, for each processor in subcommunicator</span>

<span class="kt">bool</span> <span class="n">is_set</span><span class="p">;</span>
<span class="n">grid</span><span class="p">(</span><span class="kt">int</span> <span class="n">gdims_</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="kt">int</span> <span class="n">pgrid_</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="kt">int</span> <span class="n">proc_order_</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="kt">int</span> <span class="n">mem_order</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
<span class="n">MPI_Comm</span> <span class="n">mpicomm_</span><span class="p">);</span>
<span class="n">grid</span><span class="p">(</span><span class="k">const</span> <span class="n">grid</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
<span class="n">grid</span><span class="p">()</span> <span class="p">{};</span>
<span class="o">~</span><span class="n">grid</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">set_mo</span><span class="p">(</span><span class="kt">int</span> <span class="n">mo</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">{</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">mem_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mo</span><span class="p">[</span><span class="n">i</span><span class="p">];};</span>

<span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="section" id="grid-constructor">
<h3><a class="toc-backref" href="#id4"><em>grid</em> constructor</a><a class="headerlink" href="#grid-constructor" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span><span class="p">(</span><span class="kt">int</span> <span class="n">gdims</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="kt">int</span> <span class="n">dim_conj_sym</span><span class="p">,</span><span class="kt">int</span> <span class="n">pgrid</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="kt">int</span> <span class="n">proc_order</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="kt">int</span> <span class="n">mem_order</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">MPI_Comm</span> <span class="n">mpicomm</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Function</em>:Initializes a new grid with specified parameters.</p>
<p><em>Arguments</em>:</p>
<table border="1" class="colwidths-auto docutils">
<tbody valign="top">
<tr class="row-odd"><td>gdims</td>
<td>Three global grid dimensions (logical order - X, Y, Z)</td>
</tr>
<tr class="row-even"><td>dim_conj_sym</td>
<td>Dimension of conjugate symmetry, non-negative only for complex arrays resulting from real-to-complex FFT in the given dimension. This is logical, not storage, dimension, with valid numbers 0 - 2, and -1 implying no conjugate symmetry.</td>
</tr>
<tr class="row-odd"><td>pgrid</td>
<td>Up to three dimensions of processor grid, decomposing the global grid array. Value =1 means the grid is not decomposed but is local in that logical dimension.</td>
</tr>
<tr class="row-even"><td>proc_order</td>
<td>A permutation of the 3 integers: 0, 1 and 2. Specifies the topology of processor grid on the interconnect. The dimension with lower value means the MPI tasks in that dimension are closer in ranks, e.g. value=0 means the ranks are adjacent (stride=1), value=1 means they are speard out with the stride equal to the pgrid value of the dimension with stride=1 etc</td>
</tr>
<tr class="row-odd"><td>mem_order</td>
<td>A permutation of the 3 integers: 0, 1 and 2. Specifies mapping of the logical dimension and memory storage dimensions for local memory for each MPI task. mem_order[i0] = 0 means that the i0's logical dimension is stored with stride=1 in memory. Similarly, mem_order[i1] =1 means that i1's logical dimension is stored with stride=ldims[i0] etc</td>
</tr>
<tr class="row-even"><td>mpicomm</td>
<td>The MPI communicator in which this grid lives</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="p3dfft-transforms">
<h2><a class="toc-backref" href="#id5">P3DFFT++ Transforms</a><a class="headerlink" href="#p3dfft-transforms" title="Permalink to this headline">¶</a></h2>
<p>P3DFFT++ functions in a way similar to FFTW: first the user needs to plan a transform, using a planner function once per each transform type. The planner function initializes the transform, creates a plan and stores all information relevant to this transform inside P3DFFT++. The users gets a handle referring to this plan (which is a class in C++) that can be later used to execute this transform, and can be applied multiple times. The handles can be released after use.</p>
<p>In order to define and plan a transform (whether 1D or 3D) one needs to first define initial and final grid objects. They contain all the necessary grid decomposition parameters. P3DFFT++ figures out the optimal way to transpose the data between these two grid configurations, assuming they are consistent (i.e. same grid size, number of tasks etc).</p>
<div class="section" id="one-dimensional-1d-transforms">
<h3><a class="toc-backref" href="#id6">One-Dimensional (1D) Transforms</a><a class="headerlink" href="#one-dimensional-1d-transforms" title="Permalink to this headline">¶</a></h3>
<p>The following predefined 1D transforms are available:</p>
<table border="1" class="colwidths-auto docutils">
<tbody valign="top">
<tr class="row-odd"><td>EMPTY_TYPE</td>
<td>Empty transform</td>
</tr>
<tr class="row-even"><td>R2CFFT_S, P3DFFT_R2CFFT_D</td>
<td>Real-to-complex forward FFT (as defined in FFTW manual), in single and double precision respectively</td>
</tr>
<tr class="row-odd"><td>C2RFFT_S, P3DFFT_C2RFFT_D</td>
<td>Complex-to-real backward FFT (as defined in FFTW manual), in single and double precision respectively</td>
</tr>
<tr class="row-even"><td>CFFT_FORWARD_S, CFFT_FORWARD_D</td>
<td>Complex forward FFT (as defined in FFTW manual), in single and double precision respectively</td>
</tr>
<tr class="row-odd"><td>CFFT_BACKWARD_S, CFFT_BACKWARD_D</td>
<td>Complex backward FFT (as defined in FFTW manual), in single and double precision respectively</td>
</tr>
<tr class="row-even"><td>DCT&lt;x&gt;_REAL_S, DCT1_REAL_D</td>
<td>Cosine transform for real-numbered data, in single and double precision, where &lt;x&gt; stands for the variant of the cosine transform, such as DCT1, DCT2, DCT3 or DCT4</td>
</tr>
<tr class="row-odd"><td>DST&lt;x&gt;_REAL_S, DST1_REAL_D</td>
<td>Sine transform for real-numbered data, in single and double precision, where &lt;x&gt; stands for the variant of the cosine transform, such as DST1, DST2, DST3 or DST4</td>
</tr>
<tr class="row-even"><td>DCT&lt;x&gt;_COMPLEX_S, DCT1_COMPLEX_D</td>
<td>Cosine transform for complex-numbered data, in single and double precision, where &lt;x&gt; stands for the variant of the cosine transform, such as DCT1, DCT2, DCT3 or DCT4</td>
</tr>
<tr class="row-odd"><td>DST&lt;x&gt;_COMPLEX_S, DST1_COMPLEX_D</td>
<td>Sine transform for complex-numbered data, in single and double precision, where &lt;x&gt; stands for the variant of the cosine transform, such as DST1, DST2, DST3 or DST4</td>
</tr>
</tbody>
</table>
<div class="section" id="custom-transform-types">
<h4><a class="toc-backref" href="#id7">Custom transform types</a><a class="headerlink" href="#custom-transform-types" title="Permalink to this headline">¶</a></h4>
<p>Custom 1D transforms can be defined by the user through trans_type1D class template.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Type1</span><span class="p">,</span><span class="k">class</span> <span class="nc">Type2</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">trans_type1D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">gen_trans_type</span><span class="p">{</span>

<span class="kt">int</span> <span class="n">ID</span><span class="p">;</span>
<span class="k">public</span> <span class="o">:</span>

<span class="k">typedef</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">doplan_type</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">howmany</span><span class="p">,</span><span class="n">Type1</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">inembed</span><span class="p">,</span><span class="kt">int</span> <span class="n">istride</span><span class="p">,</span><span class="kt">int</span> <span class="n">idist</span><span class="p">,</span><span class="n">Type2</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">onembed</span><span class="p">,</span><span class="kt">int</span> <span class="n">ostride</span><span class="p">,</span><span class="kt">int</span> <span class="n">odist</span><span class="p">,...);</span>

<span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">doplan</span><span class="p">)(...);</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exec</span><span class="p">)(...);</span>

<span class="n">trans_type1D</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">doplan_</span><span class="p">)(...),</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">exec</span><span class="p">)(...)</span><span class="o">=</span><span class="nb">NULL</span><span class="p">,</span><span class="kt">int</span> <span class="n">isign</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">getID</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span><span class="p">(</span><span class="n">ID</span><span class="p">);}</span>
<span class="n">trans_type1D</span><span class="p">(</span><span class="k">const</span> <span class="n">trans_type1D</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
<span class="o">~</span><span class="n">trans_type1D</span><span class="p">();</span>

<span class="p">};</span>
</pre></div>
</div>
<p>This class template is a derivative of gen_trans_type1D class, defined as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">gen_trans_type</span> <span class="p">{</span>
<span class="k">public</span> <span class="o">:</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">isign</span><span class="p">;</span> <span class="c1">// forward (-1) or backward (+1), in case this is complex FFT</span>
<span class="kt">bool</span> <span class="n">is_set</span><span class="p">,</span><span class="n">is_empty</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dt1</span><span class="p">,</span><span class="n">dt2</span><span class="p">;</span> <span class="c1">//Datatype before and after</span>
<span class="kt">int</span> <span class="n">prec</span><span class="p">;</span> <span class="c1">// precision for a real value in bytes (4 or 8)</span>
<span class="n">gen_trans_type</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name_</span><span class="p">,</span><span class="kt">int</span> <span class="n">isign_</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
<span class="o">~</span><span class="n">gen_trans_type</span><span class="p">();</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">gen_trans_type</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In order to define a custom transform type, the user needs to provide planning and execution functions (doplan and exec).  For example, in case of a complex FFT implemented through FFTW, the following is how the transform type is constructed:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Complex-to-complex Fourier Transform, forward transform, double precision&quot;</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">isign</span> <span class="o">=</span> <span class="n">FFTW_FORWARD</span><span class="p">;</span>
<span class="n">trans_type1D</span><span class="o">&lt;</span><span class="n">complex_double</span><span class="p">,</span><span class="n">complex_double</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">mytype</span> <span class="o">=</span> <span class="k">new</span> <span class="n">trans_type1D</span><span class="o">&lt;</span><span class="n">complex_double</span><span class="p">,</span><span class="n">complex_double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">name</span><span class="p">,(</span><span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="p">)(...)</span> <span class="p">)</span> <span class="n">fftw_plan_many_dft</span><span class="p">,(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(...))</span> <span class="n">exec_c2c_d</span><span class="p">,</span><span class="n">isign</span><span class="p">);</span>
</pre></div>
</div>
<p>where exec_c2c_d is defined as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">exec_c2c_d</span><span class="p">(</span><span class="kt">long</span> <span class="n">plan</span><span class="p">,</span><span class="n">complex_double</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span><span class="n">complex_double</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">fftw_execute_dft</span><span class="p">((</span><span class="n">fftw_plan</span><span class="p">)</span> <span class="n">plan</span><span class="p">,(</span><span class="n">fftw_complex</span> <span class="o">*</span><span class="p">)</span> <span class="n">in</span><span class="p">,(</span><span class="n">fftw_complex</span> <span class="o">*</span><span class="p">)</span> <span class="n">out</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="planning-1d-transform">
<h4><a class="toc-backref" href="#id8">Planning 1D transform</a><a class="headerlink" href="#planning-1d-transform" title="Permalink to this headline">¶</a></h4>
<p>1D transform in C++ is realized through transplan template class. TypeIn and TypeOut are the datatypes for input and output.</p>
<p>Two constructors are provided.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TypeIn</span><span class="p">,</span><span class="k">class</span> <span class="nc">TypeOut</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">transplan</span><span class="o">::</span><span class="n">transplan</span><span class="p">(</span><span class="k">const</span> <span class="n">grid</span> <span class="o">&amp;</span><span class="n">gridIn</span><span class="p">,</span><span class="k">const</span> <span class="n">grid</span> <span class="o">&amp;</span><span class="n">gridOut</span><span class="p">,</span><span class="k">const</span> <span class="n">gen_trans_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="k">const</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">inplace_</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TypeIn</span><span class="p">,</span><span class="k">class</span> <span class="nc">TypeOut</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">transplan</span><span class="o">::</span><span class="n">transplan</span><span class="p">(</span><span class="k">const</span> <span class="n">grid</span> <span class="o">&amp;</span><span class="n">gridIn</span><span class="p">,</span><span class="k">const</span> <span class="n">grid</span> <span class="o">&amp;</span><span class="n">gridOut</span><span class="p">,</span><span class="k">const</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span><span class="k">const</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">inplace_</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Function</em>: define and plan a 1D transform of a 3D array</p>
<p><em>Arguments</em>:</p>
<table border="1" class="colwidths-auto docutils">
<tbody valign="top">
<tr class="row-odd"><td>gridIn</td>
<td>Initial grid descriptor</td>
</tr>
<tr class="row-even"><td>gridOut</td>
<td>Final grid descriptor</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>The type of the 1D transform (either as a predefined integer parameter, or as a class gen_trans_type.</td>
</tr>
<tr class="row-even"><td>d</td>
<td>The dimension to be transformed. Note that this is the logical dimension rank (0 for X, 1 for Y, 2 for Z), and may not be the same as the storage dimension, which depends on mem_order member of gridIn and gridOut. The transform dimension of the grid is assumed to be MPI task-local.</td>
</tr>
<tr class="row-odd"><td>inplace</td>
<td>True for in-place transform, false for out-of-place.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="releasing-1d-transform-handle">
<h4><a class="toc-backref" href="#id9">Releasing 1D transform handle</a><a class="headerlink" href="#releasing-1d-transform-handle" title="Permalink to this headline">¶</a></h4>
<p>To release a 1D transform handle, simply delete the corresponding transplan class.</p>
</div>
<div class="section" id="executing-1d-transform">
<h4><a class="toc-backref" href="#id10">Executing 1D transform</a><a class="headerlink" href="#executing-1d-transform" title="Permalink to this headline">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TypeIn</span><span class="p">,</span><span class="k">class</span> <span class="nc">TypeOut</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">transplan</span><span class="o">::</span><span class="n">exec</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">In</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Out</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Function</em>: Executes the pre-planned 1D transform of a 3D array</p>
<p><em>Arguments</em>:</p>
<table border="1" class="colwidths-auto docutils">
<tbody valign="top">
<tr class="row-odd"><td>In and Out</td>
<td>Pointers to input and output arrays, cast as pointers to char. They contain the local portion of the 3D input and output arrays, arranged as a contiguous sequence of numbers according to local grid dimensions and the memory order of initial and final grid objects respectively.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the transform is out-of-place, then these arrays must be non-overlapping. The execution can be performed many times with the same handle and same or different input and output arrays.</p>
</div>
</div>
</div>
<div class="section" id="three-dimensional-transforms">
<h3><a class="toc-backref" href="#id11">Three-dimensional Transforms</a><a class="headerlink" href="#three-dimensional-transforms" title="Permalink to this headline">¶</a></h3>
<p>Three-dimensional (3D) transforms consist of three one-dimensional transforms in sequence (one for each dimension), interspersed by inter-processor transposes. In order to specify a 3D transform, three main things are needed:</p>
<ol class="arabic simple">
<li>Initial grid (as described above, grid object defines all of the specifics of grid dimensions, memory ordering and distribution among processors).</li>
<li>Final grid.</li>
<li>The type of 3D transform.</li>
</ol>
<p>The final grid may or may not be the same as the initial grid. First, in real-to-complex and complex-to-real transforms the global grid dimensions change for example from (n0,n1,n2) to (n0/2+1,n1,n2), since most applications attempt to save memory by using the conjugate symmetry of the Fourier transform of real data. Secondly, the final grid may have different processor distribution and memory ordering, since for example many applications with convolution and those solving partial differential equations do not need the initial grid configuration in Fourier space. The flow of these applications is typically 1) transform from physical to Fourier space, 2) apply convolution or derivative calculation in Fourier space, and 3) inverse FFT to physical space. Since forward FFT's last step is 1D FFT in the third dimension, it is more efficient to leave this dimension local and stride-1, and since the first step of the inverse FFT is to start with the third dimension 1D FFT, this format naturally fits the algorithm and results in big savings of time due to elimination of several extra transposes.</p>
<p>In order to define the 3D transform type one needs to know three 1D transform types comprising the 3D transform. In C++ 3D transform type is interfaced through a class trans_type3D.</p>
<div class="section" id="trans-type3d-constructor">
<h4><a class="toc-backref" href="#id12">trans_type3D constructor</a><a class="headerlink" href="#trans-type3d-constructor" title="Permalink to this headline">¶</a></h4>
<p>Two constructors are provided for trans_type3D (in addition to a copy constructor):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">trans_type3D</span><span class="o">::</span><span class="n">trans_type3D</span><span class="p">(</span><span class="k">const</span> <span class="n">gen_trans_type</span> <span class="o">*</span><span class="n">types_</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="n">trans_type3D</span><span class="o">::</span><span class="n">trans_type3D</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">types</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
</pre></div>
</div>
<p>Types is an array of 3 1D transform types, either as integer type IDs, or gen_trans_type classes.</p>
<p>trans_type3D class has the following public members:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dtIn</span><span class="p">,</span><span class="n">dtOut</span><span class="p">;</span> <span class="c1">// Datatypes for input and output: 1 is real, 2 is complex</span>
<span class="kt">int</span> <span class="n">prec</span><span class="p">;</span> <span class="c1">// Datatype precision for a real value in bytes: 4 for single, 8 for double precision</span>

<span class="kt">bool</span> <span class="n">is_set</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">types</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// 3 1D transform types</span>
</pre></div>
</div>
</div>
<div class="section" id="transform3d-constructor">
<h4><a class="toc-backref" href="#id13">Transform3D constructor</a><a class="headerlink" href="#transform3d-constructor" title="Permalink to this headline">¶</a></h4>
<p>In C++ 3D transforms are handled through class template transform3D, with input and output datatypes TypeIn and TypeOut. Often these will be the same, however some transforms have different types on input and output, for example real-to-complex FFT. In all cases the floating point precision (single/double) of the initial and final types should match.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">TypeIn</span><span class="p">,</span><span class="k">class</span> <span class="nc">TypeOut</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">transform3D</span><span class="o">::</span><span class="n">transform3D</span><span class="p">(</span> <span class="k">const</span> <span class="n">grid</span> <span class="o">&amp;</span><span class="n">grid_in</span><span class="p">,</span> <span class="k">const</span> <span class="n">grid</span> <span class="o">&amp;</span><span class="n">grid_out</span><span class="p">,</span> <span class="k">const</span> <span class="n">trans_type3D</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">inplace</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">Overwrite</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Function</em>: defines and plans a 3D transform</p>
<p><em>Arguments</em>:</p>
<table border="1" class="colwidths-auto docutils">
<tbody valign="top">
<tr class="row-odd"><td>gridIn</td>
<td>Initial grid configuration</td>
</tr>
<tr class="row-even"><td>gridOut</td>
<td>Final grid configuration</td>
</tr>
<tr class="row-odd"><td>type</td>
<td>pointer to a 3D transform type class</td>
</tr>
<tr class="row-even"><td>inplace</td>
<td>true is this is an in-place transform; false if an out-of-place transform.</td>
</tr>
<tr class="row-odd"><td>Overwrite (optional)</td>
<td>Indicates whether input can be overwritten (true=yes, default is no)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="transform3d-execution">
<h4><a class="toc-backref" href="#id14">Transform3D Execution</a><a class="headerlink" href="#transform3d-execution" title="Permalink to this headline">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">TypeIn</span><span class="p">,</span><span class="k">class</span> <span class="nc">TypeOut</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">transform3D</span><span class="o">::</span><span class="n">exec</span><span class="p">(</span><span class="n">TypeIn</span> <span class="o">*</span><span class="n">In</span><span class="p">,</span><span class="n">TypeOut</span> <span class="o">*</span><span class="n">Out</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Function</em>: executes a 3D transform</p>
<p><em>Arguments</em>:</p>
<table border="1" class="colwidths-auto docutils">
<tbody valign="top">
<tr class="row-odd"><td>In and Out</td>
<td>Pointers to input and output arrays. In case of in-place transform they can point to the same location. For out-of-place transforms the arrays must be non-overlapping.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="spectral-derivative-for-3d-array">
<h4><a class="toc-backref" href="#id15">Spectral Derivative for 3D array</a><a class="headerlink" href="#spectral-derivative-for-3d-array" title="Permalink to this headline">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">TypeIn</span><span class="p">,</span><span class="k">class</span> <span class="nc">TypeOut</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">transform3D</span><span class="o">::</span><span class="n">exec_deriv</span><span class="p">(</span><span class="n">TypeIn</span> <span class="o">*</span><span class="n">In</span><span class="p">,</span><span class="n">TypeOut</span> <span class="o">*</span><span class="n">Out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idir</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Function</em>: execute 3D real-to-complex FFT, followed by spectral derivative calculation, i.e. multiplication by (ik), where i is the complex imaginary unit, and k is the wavenumber. This function is defined only for complex-valued output arrays (single or double precision), i.e. TypeOut must be either mycomplex or complex_double.</p>
<p><em>Arguments</em>:</p>
<table border="1" class="colwidths-auto docutils">
<tbody valign="top">
<tr class="row-odd"><td>In and Out</td>
<td>Pointers to input and output arrays, assumed to be the local portion of the 3D grid array stored contiguously in memory, consistent with definition of grids in planning stage.</td>
</tr>
<tr class="row-even"><td>idir</td>
<td>The dimension where derivative is to be taken in (this is logical dimension, NOT storage mapped). Valid values are 0 - 2.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>Unless inplace was defined in the planning stage of mytrans, In and Out must be non-overlapping</li>
<li>This function can be used multiple times after the 3D transform has been defined and planned.</li>
</ol>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="p3dfft++_c_reference.html" class="btn btn-neutral float-right" title="P3DFFT++ C Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="p3dfft++_tutorial.html" class="btn btn-neutral float-left" title="P3DFFT++ Tutorial" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Dmitry Pekurovsky

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>